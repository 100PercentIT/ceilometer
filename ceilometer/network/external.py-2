from ceilometer.openstack.common import log
from ceilometer.openstack.common import timeutils

from ceilometer import counter
from ceilometer.central import plugin

from quantumclient.v2_0 import client as quantum_client

from keystoneclient.v2_0 import client as ksclient
from ceilometer.openstack.common import cfg

import os, subprocess, sys, csv

class _Base(plugin.CentralPollster):


    @staticmethod
    def get_quantum_client():
        k = ksclient.Client(username=cfg.CONF.os_username,
                           password=cfg.CONF.os_password,
                           tenant_id=cfg.CONF.os_tenant_id,
                           tenant_name=cfg.CONF.os_tenant_name,
                           auth_url=cfg.CONF.os_auth_url)

        endpoint = k.service_catalog.url_for(service_type='network',
                                             endpoint_type='internalURL')

        return quantum_client.Client(token=k.auth_token,
                                     endpoint_url=endpoint)

    def iter_routers(self):
        """Iterate over all routers."""
        client = self.get_quantum_client()
        return client.list_routers()

    def iter_networks(self):
        """Iterate over all networks."""
        client = self.get_quantum_client()
        return client.list_networks()

    def iter_ports(self):
        """Iterate over all ports"""
        client = self.get_quantum_client()
        return client.list_ports()

    def build_table(self):
        """ """
        router_table = []
        routers = self.iter_routers()['routers']
        networks = self.iter_networks()['networks']
        ports = self.iter_ports()['ports']
        for router in routers:
            if router['external_gateway_info'] != None:
                if router['external_gateway_info']['network_id'] != None:
                    network_id = router['external_gateway_info']['network_id']
                    tenant_id = router['tenant_id']
                    router_id = router['id']
                    router_dict = {'router_id': router_id, 'tenant_id': tenant_id, 'network_id': network_id}
            for network in networks:
                if router_dict['network_id'] == network['id'] and network['router:external'] == True:
                    router_dict['subnets'] = network['subnets']
                    for port in ports:
                        if port['fixed_ips'][0]['subnet_id'] in router_dict['subnets'] and port['device_id'] == router_dict['router_id']:
                            router_dict['mac_address'] = port['mac_address']
                            router_table.append(router_dict)
                            return router_table


    def ifconfig(self, details):
        ifconfig_proc = subprocess.Popen(["sudo ip netns exec qrouter-" + details['router_id'] + " ifconfig | grep '" + details['mac_address'] + "' -A 7 | egrep -o '(RX|TX) (packets|bytes):[0-9]+' | egrep -o '[0-9]+'"],                                                                                             bufsize=-1, stdout=subprocess.PIPE, shell=True)
        stdout, _ = ifconfig_proc.communicate()
        if ifconfig_proc.returncode == 0:
             usage_array = stdout.split('\n')
        return usage_array[:-1]

    def get_external(self):
        x = self.build_table()
        a = []
        for i in x:
            details = self.ifconfig(i)
            i['RX Packets'] = details[0]
            i['TX Packets'] = details[1]
            i['RX Bytes'] = details[2]
            i['TX Bytes'] = details[3]
            a.append(i)
        return a



class ExternalBWPollster(_Base):

    LOG = log.getLogger(__name__ + '.externalbw')

    @staticmethod
    def get_counter_names():
        return ['ip.externalbw']


    def get_counters(self, manager, context):
        for y in self.get_external():
               yield counter.Counter(
                   name='ip.extbw.rx.packets',
                   type=counter.TYPE_CUMULATIVE,
                   volume=y['RX Packets'],
                   unit='packets',
                   user_id=None,
                   project_id=y['tenant_id'],
                   resource_id=y['network_id'],
                   timestamp=timeutils.isotime(),
                   resource_metadata=None,
                   )
               yield counter.Counter(
                   name='ip.extbw.tx.packets',
                   type=counter.TYPE_CUMULATIVE,
                   volume=y['TX Packets'],
                   unit='packets',
                   user_id=None,
                   project_id=y['tenant_id'],
                   resource_id=y['network_id'],
                   timestamp=timeutils.isotime(),
                   resource_metadata=None,
                   )
               yield counter.Counter(
                   name='ip.extbw.rx.bytes',
                   type=counter.TYPE_CUMULATIVE,
                   volume=y['RX Bytes'],
                   unit='B',
                   user_id=None,
                   project_id=y['tenant_id'],
                   resource_id=y['network_id'],
                   timestamp=timeutils.isotime(),
                   resource_metadata=None,
                   )
               yield counter.Counter(
                   name='ip.extbw.tx.bytes',
                   type=counter.TYPE_CUMULATIVE,
                   volume=y['TX Bytes'],
                   unit='B',
                   user_id=None,
                   project_id=y['tenant_id'],
                   resource_id=y['network_id'],
                   timestamp=timeutils.isotime(),
                   resource_metadata=None,
                   )
